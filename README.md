# Dandiya

Dandiya is an API description tool designed to ensure ABI stability across API changes while supporting multiple languages

Dandiya is named after the sticks used in a popular traditional Indian Wedding Dance/Garba

## Building

`cargo build --release`

## Definition files: .dy

The definition language is a Rust-inspired syntax that is semantically closer to C.

Features:
  - All functions calls are API versioned with suffixes: e.g. `_v1`, `_v2`, `_v3`, etc
  - Struct definitions are supported and are always `repr(C)`
  - Pointers are supported and are always considered `*mut`
  - Single-dimension arrays are supported
    - Multi-dimension arrays are not supported because of poor C semantics
    - Pointers to arrays are not supported because of poor C semantics
    - Arrays are not allowed in function signatures because of poor C semantic
  - Standard integer types are supported: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`
  - Definining `opaque` types and using pointers to them is supported
  - Defining constants (in C: `#define`) is supported
  
Binding generation modes:
  - C Header
  - Rust
  - In The Future: Python via Ctypes
  - In The Future: C Loader via dlopen

## Example

### API Definition
Command: `cat example.dy`
```
/******************************************************************
 * This is a example of the capabilities that dandiya provides.
 * For example: this is a block-comment that will be faithfully
 * preserved in the output
 *****************************************************************/

// Result codes that can be returned
const EXAMPLE_SUCCESS = 0;
const EXAMPLE_ERR_AGAIN = 1;
const EXAMPLE_ERR_UNKNOWN = 2;

// Example context: opaque
opaque example_ctx;

// Packet structure
struct example_packet {
  len: u16,
  dat: [u8; 1500],
}

// Batch of packets
struct example_batch {
  num: u8,
  pkts: [example_packet; 16],
}

// Create a new context
fn(v1) example_new() -> *example_ctx;
fn(v2) example_new(n: u64) -> *example_ctx;

// Destroy a context
fn(v1) example_delete(ctx: *example_ctx);

// Retrieve a batch of packets
fn(v1) example_fetch_batch(ctx: *example_ctx, b: *example_batch) -> u64;
```

### Generate C bindings
Command: `./target/release/dandiya example.dy --emit c-header`
```
/*******************************************************************************
 * Autogenerated by Dandiya API Generator
 ******************************************************************************/
#pragma once
#include <stdint.h>

#ifndef DANDIYA_API_EXPORT
#  if defined(__GNUC__) || defined(__clang__)
#    define DANDIYA_API_EXPORT __attribute__((visibility("default")))
#  else
#    error Unsupported compiler
#  endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************
 * This is a example of the capabilities that dandiya provides.
 * For example: this is a block-comment that will be faithfully
 * preserved in the output
 *****************************************************************/

// Result codes that can be returned
#define EXAMPLE_SUCCESS ((uint64_t)(0))
#define EXAMPLE_ERR_AGAIN ((uint64_t)(1))
#define EXAMPLE_ERR_UNKNOWN ((uint64_t)(2))

// Example context: opaque
typedef struct example_ctx example_ctx_t;

// Packet structure
typedef struct example_packet example_packet_t;
struct example_packet {
  uint16_t len;
  uint8_t dat[1500];
};

// Batch of packets
typedef struct example_batch example_batch_t;
struct example_batch {
  uint8_t num;
  example_packet_t pkts[16];
};

// Create a new context
DANDIYA_API_EXPORT example_ctx_t* example_new_v1(void);
DANDIYA_API_EXPORT example_ctx_t* example_new_v2(uint8_t n);

// Destroy a context
DANDIYA_API_EXPORT void example_delete_v1(example_ctx_t* ctx);

// Retrieve a batch of packets
DANDIYA_API_EXPORT uint64_t example_fetch_batch_v1(example_ctx_t* ctx, example_batch_t* b);

/*******************************************************************************
 * API Inlines
 ******************************************************************************/
static inline example_ctx_t* example_new(uint8_t n) { return example_new_v2(n); }
static inline void example_delete(example_ctx_t* ctx) { return example_delete_v1(ctx); }
static inline uint64_t example_fetch_batch(example_ctx_t* ctx, example_batch_t* b) { return example_fetch_batch_v1(ctx, b); }

#ifdef __cplusplus
}
#endif
```

### Generate Rust bindings
Command: `./target/release/dandiya example.dy --emit rust`
```
/*******************************************************************************
 * Autogenerated by Dandiya API Generator
 ******************************************************************************/
#![allow(dead_code)]

/******************************************************************
 * This is a example of the capabilities that dandiya provides.
 * For example: this is a block-comment that will be faithfully
 * preserved in the output
 *****************************************************************/

// Result codes that can be returned
pub const EXAMPLE_SUCCESS: u64 = 0;
pub const EXAMPLE_ERR_AGAIN: u64 = 1;
pub const EXAMPLE_ERR_UNKNOWN: u64 = 2;

// Example context: opaque
#[repr(C)]
pub struct example_ctx {_opaque_data: [u8; 0]}

// Packet structure
#[repr(C)]
pub struct example_packet {
  pub len: u16,
  pub dat: [u8; 1500],
}

// Batch of packets
#[repr(C)]
pub struct example_batch {
  pub num: u8,
  pub pkts: [example_packet; 16],
}

// Create a new context
extern "C" { pub fn example_new_v1() -> *mut example_ctx; }

// Destroy a context
extern "C" { pub fn example_delete_v1(ctx: *mut example_ctx); }

// Retrieve a batch of packets
extern "C" { pub fn example_fetch_batch_v1(ctx: *mut example_ctx, b: *mut example_batch) -> u64; }

/*******************************************************************************
 * API Inlines
 ******************************************************************************/
pub unsafe fn example_new() -> *mut example_ctx { example_new_v1() }
pub unsafe fn example_delete(ctx: *mut example_ctx) { example_delete_v1(ctx) }
pub unsafe fn example_fetch_batch(ctx: *mut example_ctx, b: *mut example_batch) -> u64 { example_fetch_batch_v1(ctx, b) }
```

